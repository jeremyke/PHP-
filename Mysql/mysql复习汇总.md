 ## 1锁
 
 ##### 1.1 简述MySQL的锁机制？
 
 ```text
    排它锁(也称独占锁、写锁或X锁)和共享锁(也称读锁或S锁)：
    (1)若sessionA获得某数据表的共享锁权限，那么任何session（包括sessionA）都能对该表进行读取，但是都不能修改该表。
    (2)若sessionA获得某数据表的排他锁权限，那么只有sessionA可以对该表进行读取或修改，其他session既不能读取也不能修改该表，更不能对该表加任何类型的锁，直到sessionA释放
    排它锁权限。加锁方式：lock tables tablename write/reade;释放锁：unlock tables;
    (3)若sessionA既获得某数据表的共享锁同时获取了该数据表的排它锁，那么只有sessionA可以对该表进行读取或修改，其他session既不能读取也不能修改该表。
    
    mysql中，myIsam引擎和InnoDB引擎，默认的修改数据语句（update,delete,insert）都会自动给涉及到的数据加上排他锁；
    myIsam引擎，非事务型，支持表锁。在select 语句默认加表读锁。
    InnoDB引擎，事务型，支持行锁。在select 语句默认加行读锁。但可以通过select ...for update 和select ... lock in share mode显性加锁。
 ```
 ##### 1.2 MySQL事务？
  
  - ACID四种属性
  
  ```text
   (1)原子性（atomicity）
   (2)一致性（consistency）
   (3)隔离性（isolation）
   (4)持久性（durability）
  ```
  - 事务隔离级别
  
  ```text
  (1)未提交读(READ UNCOMMITTED)
  这就是上面所说的例外情况了,这个隔离级别下,其他事务可以看到本事务没有提交的部分修改.因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).
  这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.
  
  (2)已提交读(READ COMMITTED)
  其他事务只能读取到本事务已经提交的部分.这个隔离级别有 不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.
  
  (3)REPEATABLE READ(可重复读)
  可重复读隔离级别解决了上面不可重复读的问题(看名字也知道),但是仍然有一个新问题,就是 幻读,当你读取id> 10的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.
  这个隔离级别也是Innodb存储引擎默认的隔离级别.
  
  (4)SERIALIZABLE(可串行化)
  这是最高的隔离级别,可以解决上面提到的索引问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.
  ```
  - 事务的实现原理
  ```text
    事务日志是通过redo日志和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号;
    当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），
    也就是写数据前，需要先写日志。这种方式称为“预写日志方式”
  ``` 
  
 ##### 1.3 简述MySQL的MVCC？
  ```text
 加锁是一种控制并发的方式,但是加锁毕竟是一个比较消耗资源的操作,因此MySQL也实现了MVCC(Multi-Version Concurrency Control ),核心思想是未每一条数据加
 上两个版本号,一个是当前的数据版本号,一个是该数据的删除版本号.通过版本的控制,在一定程度上尚避免加锁也可以实现并发控制.
 
 在MySQL中,MVCC的大致工作原理如下:
 select
 查询语句指挥获取符合下面两个条件的数据:
 数据版本号小于等于当前事务的版本号,这样可以保证查到的数据要么是之前就存在的,要么是本事务操作的.
 数据的删除版本号要么为空,要么大于事务当前的版本号.这样可以保证在此事务之前,该行数据没有被删除.
 
 insert
 插入数据的当前版本号等于当前事务的版本号.
 
 delete
 将删除行的删除版本号设置为当前事务的版本号.
 
 update
 对原数据进行删除操作,然后插入新数据,所以相当于上面两个操作的合集.
 ```
 
 ## 2 索引
 
 ## 3 引擎
 

 
 #### 1.MySQL的复制原理以及流程
 
 基本原理流程，3个线程以及之间的关联:
 ```text
1.binlog输出线程:每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，从库就会创建两个线程进行处理：
2.从库I/O线程:当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。
3.从库的SQL线程:从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。
 ```
 #### 2.MySQL中myisam与innodb的区别
 
 |不同点|myisam|innodb|
 |:----    |:---:|:-----:|
 |（1）存储方式|数据和索引是分开存储的（3个文件（frm、MYD、MYI））|数据和索引是一起存储的（共享表空间存储和多表空间存储两种方式），2个存储文件（.ibd，.frm）|
 |（2）存储顺序|插入顺序|主键顺序|
 |（3）空间碎片的产生|会产生，需要定时清理（optimize table 表名）|不会产生|
 |（4）事务和外键约束|不支持|支持|
 |（5）锁级别|表锁|行锁|
 |（5）读写插入|快速|更新删除快速|
 
 #### 3.MySQL中字段类型
 
 - varchar(50)中50的涵义
 
 首先明确：mysql中UTF-8编码,汉字字符占3个字节，英文字符占1个字节。这里50表示最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)
 
 - int（20）中20的涵义
 
 首先明确int类型只能占用4个字节的存储空间，这里20是指最大显示宽度，但是最大显示宽度为255。如果存储数据不够显示宽度，设置UNSIGNED ZEROFILL(无符号）就会在数据左侧用0来填充位数。
 


 #### 5.MySQL数据库cpu飙升到500%的话他怎么处理？
 ```text
 1、列出所有进程  show processlist,观察所有进程 ,多秒没有状态变化的(干掉)
 2、查看超时日志或者错误日志 ,一般会是查询以及大批量的插入会导致cpu与i/o上涨,当然不排除网络状态突然断了,导致一个请求服务
 器只接受到一半，比如where子句或分页子句没有发送,当然的一次被坑经历.
 ```
 ##### 6.超键、候选键、主键、外键分别是什么？
 ```text

1、超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
2、候选键：是最小超键，即没有冗余元素的超键。
3、主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
4、外键：在一个表中存在的另一个表的主键称此表的外键。
```
 ##### 7.mysql数据实时同步到Elasticsearch
 ```text
记录mysql的binlog日志，再执行ES document api，将数据同步到ES集群中。
mypipe同步数据到ES集群使用注意：
    1. mysql binlog必须是ROW模式
    2. 要赋予用于连接mysql的账户REPLICATION权限
       GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'elastic'@'%' IDENTIFIED BY 'Elastic_123'
    3. mypipe只是将binlog日志内容解析后编码成Avro格式推送到kafka broker, 并不是将数据推送到kafka，如果需要同步到ES集群，可以从kafka消费数据后，再写入ES
    4. 消费kafka中的消息(mysql insert, update, delete操作及具体的数据)，需要对消息内容进行Avro解析，获取到对应的数据操作内容，进行下一步处理；mypipe封装了一个KafkaGenericMutationAvroConsumer类，可以直接继承该类使用，或者自行解析
    5. mypipe只支持binlog同步，不支持存量数据同步，也即mypipe程序启动后无法对mysql中已经存在的数据进行同步
mypipe同步数据到ES集群：
    mypipe将数据binlog event发送到kafka,再写一个消费方法，将mypipe推送到kafka的消息消费掉。

```

 
 
 