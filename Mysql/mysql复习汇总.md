 ## 1锁
 
 ##### 1.1 锁分类
 ```text
(1) 共享/排它锁(Shared and Exclusive Locks)
共享锁和排他锁是InnoDB引擎实现的标准行级别锁。拿共享锁是为了让当前事务去读一行数据。拿排他锁是为了让当前事务去修改或删除某一行数据。
设置共享锁：select * from user where id = 1 LOCK IN SHARE MODE;
设置排他锁：select * from user where id = 1 FOR UPDATE;

(2) 意向锁(Intention Locks)
意向锁存在的意义在于，使得行锁和表锁能够共存。意向锁是表级别的锁，用来说明事务稍后会对表中的数据行加哪种类型的锁(共享锁或独占锁)。
当一个事务对表加了意向排他锁时，另外一个事务在加锁前就会通过该表的意向排他锁知道前面已经有事务在对该表进行独占操作，从而等待。

(3) 记录锁(Record Locks)
记录锁是索引记录上的锁，例如：SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;会阻止其他事务对c1=10的数据行进行插入、更新、删除等操作。
记录锁总是锁定索引记录。如果一个表没有定义索引，那么就会去锁定隐式的“聚集索引”。

(4) 间隙锁(Gap Locks)
间隙锁是一个在索引记录之间的间隙上的锁。一个间隙可能跨越单个索引值、多个索引值，甚至为空。对于使用唯一索引 来搜索唯一行的语句，只加记录锁
不加间隙锁(这并不包括组合唯一索引）。

(5) 临键锁(Next-key Locks)
Next-Key Locks是行锁与间隙锁的组合。当InnoDB扫描索引记录的时候，会首先对选中的索引记录加上记录锁（Record Lock），然后再对索引记录两边的间隙加
上间隙锁（Gap Lock）。

(6) 插入意向锁(Insert Intention Locks)
插入意向锁是在数据行插入之前通过插入操作设置的间隙锁定类型。
如果多个事务插入到相同的索引间隙中，如果它们不在间隙中的相同位置插入，则无需等待其他事务。例如：在4和7的索引间隙之间两个事务分别插入5和6，则两个事务不会发冲突阻塞。 

(7) 自增锁(Auto-inc Locks)
自增锁是事务插入到有自增列的表中而获得的一种特殊的表级锁。如果一个事务正在向表中插入值，那么任何其他事务都必须等待，保证第一个事务插入的行是连续的自增值。
 ```
 ##### 1.2 简述MySQL的锁机制？
 
 ```text
    排它锁(也称独占锁、写锁或X锁)和共享锁(也称读锁或S锁)：
    (1)若sessionA获得某数据表的共享锁权限，那么任何session（包括sessionA）都能对该表进行读取，但是都不能修改该表。
    (2)若sessionA获得某数据表的排他锁权限，那么只有sessionA可以对该表进行读取或修改，其他session既不能读取也不能修改该表，更不能对该表加任何类型的锁，直到sessionA释放
    排它锁权限。加锁方式：lock tables tablename write/reade;释放锁：unlock tables;
    (3)若sessionA既获得某数据表的共享锁同时获取了该数据表的排它锁，那么只有sessionA可以对该表进行读取或修改，其他session既不能读取也不能修改该表。
    
    两种引擎对索引的支持的区别：
    （1）MyISAM:myisam只支持表锁,所有的锁机制是数据库自动加载的,在select时加读锁,在update,insert,delete写锁,读锁只兼容读锁,写锁排斥任何锁!也就是说当表存在写锁时,
     其他的操作只能排队等待了!
    （2）InnoDB:支持行锁,简单来说就是语句中使用到了索引,数据库就对对应的行加锁,如果没有用到索引,则将全表加锁.InnoDB在update,insert,delete给对应数据加排他锁,
    select通常情况下不加锁，意向锁是InnoDB自动加的，不需要用户干预.但可以通过select ...for update 和select ... lock in share mode显性加锁。
    
 ```
 ![image](https://github.com/jeremyke/PHPBlog/raw/master/Pictures/fc3d9ccb5e230ce9d260831588e78a8a_20181212202951237.png)
 
 ##### 1.3 MySQL事务？
  
  - ACID四种属性
  
  ```text
   (1)原子性：事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
   (2)一致性：:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
   (3)隔离性：事务中的所有操作在为提交之前多其他事务是不可见的。
   (4)持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。
  ```
  - 事务隔离级别
  
  ```text
  (1)未提交读(READ UNCOMMITTED)
  其他事务可以看到本事务没有提交的部分修改，因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚)。这个级别的性能没有足够大的优势,
  但是又有很多的问题,因此很少使用。
  此时select语句不加任何锁。此时并发最高，但会产生脏读。
  
  (2)已提交读(READ COMMITTED)
  其他事务只能读取到本事务已经提交的部分，这个隔离级别有不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.
  普通select语句是快照读。update语句、delete语句、显示加锁的select语句（select … in share mode 或者 select … for update） 等，除了在外键约束检查和
  重复键检查时会封锁区间，其他情况都只使用记录锁；
  
  (3)REPEATABLE READ(可重复读)
  可重复读隔离级别解决了上面不可重复读的问题,但是仍然有一个新问题,在同一个事务内的两次读取,无论其他事务有没有修改这行数据，拿到的结果都是一样的。但是会产生就幻读，
  当你读取id> 10的数据行时,对涉及到的所有行加上了读锁,此时另外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次
  的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题，增加范围锁来解决这个问题。这个隔离级别也是Innodb存储引擎默认的隔离级别，这种隔离级别下使用了MVCC机制。
  普通select语句也是快照读。update语句、delete语句、显示加锁的select语句（select … in share mode 或者 select … for update）则要分情况：
  在唯一索引上使用唯一的查询条件，则使用记录锁。如: select * from user where id = 1;其中id建立了唯一索引。
  在唯一索引上使用 范围查询条件，则使用间隙锁与临键锁。如: select * from user where id >20;
  
  (4)SERIALIZABLE(可串行化)
  这是最高的隔离级别,可以解决上面提到的索引问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.
  此时所有select语句都会被隐式加锁：select … in share mode.
  ```
  - 快照读、当前读
  ```text
MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。
快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。
当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。
```
  - 事务的实现原理
  ```text
    事务日志是通过redo日志和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号;
    当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），
    也就是写数据前，需要先写日志。这种方式称为“预写日志方式”
  ``` 
  
 ##### 1.4 简述MySQL的MVCC？
  ```text
 加锁是一种控制并发的方式,但是加锁毕竟是一个比较消耗资源的操作,因此MySQL也实现了MVCC(Multi-Version Concurrency Control ),核心思想是未每一条数据加
 上两个版本号,一个是当前的数据版本号,一个是该数据的删除版本号.通过版本的控制,在一定程度上尚避免加锁也可以实现并发控制.
 
 在MySQL中,MVCC的大致工作原理如下:
 select
 查询语句指挥获取符合下面两个条件的数据:
 数据版本号小于等于当前事务的版本号,这样可以保证查到的数据要么是之前就存在的,要么是本事务操作的.
 数据的删除版本号要么为空,要么大于事务当前的版本号.这样可以保证在此事务之前,该行数据没有被删除.
 
 insert
 插入数据的当前版本号等于当前事务的版本号.
 
 delete
 将删除行的删除版本号设置为当前事务的版本号.
 
 update
 对原数据进行删除操作,然后插入新数据,所以相当于上面两个操作的合集.
 ```
 ##### 1.5 悲观锁与乐观锁？
 ```text
悲观锁和乐观锁只是对数据验证的两种不同方式!只是一种概念。
悲观锁:对数据的修改持以保守的态度,是利用数据库的锁机制,对修改的数据加排他锁!
乐观锁：相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测, 较为盛行的方法有两种
1）使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。
当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。
2）在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。

两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生
冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。另外，高并发情况下个人认为乐观锁要好于悲观锁，因为悲观锁的机制使得各个线程
等待时间过长，极其影响效率，乐观锁可以在一定程度上提高并发度!
 ```
  
 ## 2 索引
 >索引是存储引擎用于快速找到记录的一种数据结构，使得索引关键字和数据建立对应关系。
 
 #### 2.1 索引的实现原理？
 索引目的是通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。
 数据库就是把数据分成若干段，精确定位查找范围，去除无效数据，提高查找速度。
 
 #### 2.2 索引的数据结构？
 
 - B-Tree结构
 ```text
查询数据是从索引的根节点开始，节点槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过节点页的值和要查找的值可以找到合适的指针进入下一层子节点，
最终找到对应的数据。索引关键字和数据都放在节点上，没有叶子节点。

```
 ![image](https://github.com/jeremyke/PHPBlog/raw/master/Pictures/170010137312789.png)
 
 - 哈希结构
 ```text
对于每一行数据，根据存储引擎的所有列，生成哈希码，将所有的哈希码存放在索引中，同时哈希表中保存每个数据行的指针。精确匹配所有列才有效。
 ```
 - B+Tree结构
 
    - 聚簇索引
     ```text
    在B-Tree基础上，把索引关键字和数据存放在一起的，数据行的所有数据全部存放在叶子节点上，紧紧相连，称之为聚簇索引。InnoDB的主键索引为聚簇结构。
     ```
    - 辅助索引
    ```text
     在B-Tree基础上，把索引关键字和数据存放在一起的，只有数据行的主键字段的值存放在叶子节点上，每个叶子节点中的索引行中还包含一个书签（bookmark），
     其实这个书签你可以理解为是一个{'name字段'，name的值，主键id值}的这么一个数据。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据。
     会有回表。如果查询的字段属于索引的一个列（覆盖索引），直接可以在辅助索引的的叶子节点上找到数据，无需回表。

  
    ```
 #### 2.3 索引的分类
 ```text
 主键索引：
        主键索引：primary key ：加速查找+约束（不为空且唯一）
 辅助索引：
        普通索引index :加速查找
        唯一索引：unique：加速查找+约束 （唯一）
        全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。
        空间索引spatial :了解就好，几乎不用
        联合索引
            -primary key(id,name):联合主键索引
            -unique(id,name):联合唯一索引
            -index(id,name):联合普通索引
 ```
 #### 2.4 索引的优点
  
  ```text
（1）减少服务器需要扫描的数据量。
（2）帮助数据库避免排序和临时表。
（3）索引可以将随机I/O变为顺序I/O

 ``` 
 #### 2.5 索引的使用策略及其优化
 
 - 最左前缀原理与相关优化
 ```text
 （1）全列匹配：当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。即使顺序不一致，MySQL查询优化器会调整查询语句，
 使得were字段顺序和联合索引顺序一致。
 （2）最左前缀匹配：比如创建index a ('colus1','colus2','colus3')，相当于创建了索引('colus1')，（'colus1','colus2'），（'colus1','colus2','colus3'）
 （3）
 （4）如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。
 ```
 - 范围问题
 ```text
 （1）条件中出现这些符号或关键字：>、>=、<、<=、!= 、between...and...、like，对于主键索引，除了%置前的like,均会应用到索引。对于辅助索引，
  范围列可以用到索引（必须是最左前缀），比如（>,<）但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。
  当范围很小10%时，相当于I多值精确匹配，会用到索引。
 （2）通配符写在最左边是无法命中索引的，一般写在后面。
 ```
 - 区分度高的列作为索引
 ```text
 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，
 而一些状态、性别字段可能在大数据面前区分度就是0。使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。
 ```
 - 前缀索引
 ```text
 列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。
 例如：SELECT count(DISTINCT(concat(first_name, n)))/count(*) AS Selectivity FROM employees.employees,当这个值很接近SELECT count(
 DISTINCT(concat(first_name)))/count(*) AS Selectivity FROM employees.employees就可以选择。
 ```
 - 索引不能参与计算
 ```text
索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，
但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。
 ```
 
 - 索引选择性
 ```text
 索引的代价：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。
 建索引依据：以2000行数据为分界线，大于2000需要建索引。当索引关键字取值范围比较少时，不宜建索引。
 ```
 
 
 ## 3 复制
 
 #### 3.1 MySQL的日志
 ```text
 1.错误日志(error log)：记录mysql服务的启停时正确和错误的信息，还记录启动、停止、运行过程中的错误信息。
 2.查询日志(general log)：记录建立的客户端连接和执行（DQL）的语句。
 3.二进制日志(bin log)：记录所有更改数据的语句(DML,DDL)，可用于数据复制。
 4.慢查询日志(slow log)：记录所有执行时间超过long_query_time的所有查询或不使用索引的查询。
 5.中继日志(relay log)：主从复制时使用的日志。
 ``` 
 
 #### 3.1 MySQL的复制原理以及流程
 
 ![image](https://github.com/jeremyke/PHPBlog/raw/master/Pictures/4cec534924595826947f6957e010b801_master-slave.png)
 
 - 基本原理流程，3个线程以及之间的关联:
 ```text
1.binlog输出线程:每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，从库就会创建两个线程进行处理：
2.从库I/O线程:当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。
  从库I/O线程读取主库的binlog更新到中继日志relay log文件。
3.从库的SQL线程:负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。
 ```
 - 具体步骤
 ```text
步骤一：主库db的更新事件(update、insert、delete)被写到binlog
步骤二：从库发起连接，连接到主库
步骤三：此时主库创建一个binlog dump thread线程，把binlog的内容发送到从库
步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log.
步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db.
 ```
 
 ##### 3.2 mysql数据实时同步到Elasticsearch
  ```text
 记录mysql的binlog日志，再执行ES document api，将数据同步到ES集群中。
 mypipe同步数据到ES集群使用注意：
     1. mysql binlog必须是ROW模式
     2. 要赋予用于连接mysql的账户REPLICATION权限
        GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'elastic'@'%' IDENTIFIED BY 'Elastic_123'
     3. mypipe只是将binlog日志内容解析后编码成Avro格式推送到kafka broker, 并不是将数据推送到kafka，如果需要同步到ES集群，可以从kafka消费数据后，再写入ES
     4. 消费kafka中的消息(mysql insert, update, delete操作及具体的数据)，需要对消息内容进行Avro解析，获取到对应的数据操作内容，进行下一步处理；mypipe封装了一个KafkaGenericMutationAvroConsumer类，可以直接继承该类使用，或者自行解析
     5. mypipe只支持binlog同步，不支持存量数据同步，也即mypipe程序启动后无法对mysql中已经存在的数据进行同步
 mypipe同步数据到ES集群：
     mypipe将数据binlog event发送到kafka,再写一个消费方法，将mypipe推送到kafka的消息消费掉。
 
 ```
 
 ## 4 存储引擎
  
 #### 4.1 MySQL中myisam与innodb的区别
 
 |不同点|myisam|innodb|
 |:----    |:---:|:-----:|
 |（1）存储方式|数据和索引是分开存储的（3个文件（frm、MYD、MYI））|数据和索引是一起存储的（共享表空间存储和多表空间存储两种方式），2个存储文件（.ibd，.frm）|
 |（2）存储顺序|插入顺序|主键顺序|
 |（3）空间碎片的产生|会产生，需要定时清理（optimize table 表名）|不会产生|
 |（4）事务和外键约束|不支持|支持|
 |（5）锁级别|表锁|行锁|
 |（5）读写插入|快速|更新删除快速|
 
 
 ## 5 其他
  
 #### 5.1 MySQL中字段类型
 
 - varchar(50)中50的涵义
 
 首先明确：mysql中UTF-8编码,无论是一个汉字，英文，还是数字都占3个字节。这里50表示最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)
 
 - int（20）中20的涵义
 
 首先明确int类型只能占用4个字节的存储空间，这里20是指最大显示宽度，但是最大显示宽度为255。如果存储数据不够显示宽度，设置UNSIGNED ZEROFILL(无符号）就会在数据左侧用0来填充位数。
 
 ##### 5.2 超键、候选键、主键、外键分别是什么？
 
 ```text
 1、超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
 2、候选键：是最小超键，即没有冗余元素的超键。
 3、主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
 4、外键：在一个表中存在的另一个表的主键称此表的外键。
 ```

 #### 5.3 MySQL数据库cpu飙升到500%的话他怎么处理？
 ```text
 1、列出所有进程  show processlist,观察所有进程 ,多秒没有状态变化的(干掉)
 2、查看超时日志或者错误日志 ,一般会是查询以及大批量的插入会导致cpu与i/o上涨,当然不排除网络状态突然断了,导致一个请求服务
 器只接受到一半，比如where子句或分页子句没有发送,当然的一次被坑经历.
 ```



 
 
 