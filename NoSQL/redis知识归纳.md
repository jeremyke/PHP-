## 1.特点
```text
1.支持数据持久化，可将内存中的数据保存在磁盘，重启时再次加载

2.支持其他丰富的数据结构存储

3.支持数据备份，即 master-slave 模式的数据备份
```
## 2.支持哪些数据结构

#### 2.1 STRING：字符串、整数或浮点数

- 常用命令：set/get/decr/incr/mget 等；

- 应用场景：String 是最常用的一种数据类型，普通的 key/value 存储都可以归为此类；

- 实现方式：String 在 redis 内部存储默认就是一个字符串，被 redisObject 所引用，当遇到 incr、decr 等操作时会转成数值型进行计算，此时 redisObject 的 encoding 字段为 int。

#### 2.2 HASH：散列表，存储键值对之间的映射，无序排列

- 常用命令：hget/hset/hgetall 等

- 应用场景：我们要存储一个用户信息对象数据，其中包括用户 ID、用户姓名、年龄和生日，通过用户 ID 我们希望获取该用户的姓名或者年龄或者生日；

- 实现方式：实际上就是多组key-value

#### 2.3 LIST：列表，可存储多个相同的字符串(有序，可重复)

- 常用命令：lpush/rpush/lpop/rpop/lrange 等；
    
- 应用场景：Redis list 的应用场景非常多，也是 Redis 最重要的数据结构之一，比如 twitter 的关注列表，粉丝列表等都可以用 Redis 的 list 结构来实现；消息队列；
    
-实现方式：Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis 内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。
        
#### 2.4 SET：集合，存储不同元素，无序排列（无序，不可重复）

- 常用命令：sadd/spop/smembers/sunion 等；

- 应用场景：Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，
             set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的；
             
- 实现方式：set 的内部实现是一个 value 永远为 null 的 HashMap，实际就是通过计算 hash 的方式来快速排重的，这也是 set 能提供判断一个成员是否在集合内的原因
        


#### 2.5 ZSET：有序集合，存储键值对，有序排列

- 常用命令：zadd/zrange/zrem/zcard 等；

- 应用场景：Redis sorted set 的使用场景与 set 类似，区别是 set 不是自动有序的，而 sorted set 可以通过用户额外提供一个优先级 (score) 的参数来为成员排序，
             并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择 sorted set 数据结构，比如 twitter 的 public timeline 可以以发表时间作为 score 来
             存储，这样获取时就是自动按时间排好序的。
             
- 实现方式：Redis sorted set 的内部使用 HashMap 和跳跃表 (SkipList) 来保证数据的存储和有序，HashMap 里放的是成员到 score 的映射，而跳跃表里存放的
             是所有的成员，排序依据是 HashMap 里存的 score, 使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。


 
## 3.持久化策略
 
#### 3.1 RDB快照持久化
>将某一时刻的所有数据写入硬盘。使用BGSAVE命令，随着内存使用量的增加，执行 BGSAVE 可能会导致系统长时间地停顿

- 触发方式
```text
(1)使用bgsave命令手动触发
(2)自动触发(根据配置文件)

```
- 执行过程

当 Redis 需要保存 dump.rdb 文件时，服务器执行以下操作：

```text
1. Redis 调用 fork() ，同时拥有父进程和子进程。
2. 子进程将数据集写入到一个临时 RDB 文件中。
3. 当子进程完成对新RDB文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。
```
- 配置(redis.conf)
```bash
dbfilename  dump.rdb # 快照持久化备份方案
dir ./ # 快照持久化保存位置
save 900 1 # 900秒内如果超过1个key被修改, 则发起快照

```
- 优缺点

优点：
````text
1.适合用于进行备份:RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 比如说，你可以在最近的24小时内，每小时
备份一次RDB文件，并且在每个月的每一天，也备份一个RDB文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。

2.RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。

3.速度快：RDB在恢复大数据集时的速度比AOF的恢复速度要快。
````
缺点：
```text
及时性不高：如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 
但是， 因为 RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障
停机， 你就可能会丢失好几分钟的数据。
```
  
#### 3.2 AOF日志持久化
>AOF的运行原理是不断的将写入的命令以 Redis 通信协议的数据格式追加到 .aof文件末尾只追加文件，在执行写命令时，命令复制到硬盘里面。使用 AOF 策略
>需要对硬盘进行大量写入，Redis 处理速度会受到硬盘性能的限制。

- 执行过程

```text
1. Redis 执行 fork() ，现在同时拥有父进程和子进程。
2. 子进程创建新的新的AOF文件，把现有的AOF文件内容写入到新的AOF文件中。
3. 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到原来AOF文件的末尾。这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。
4. 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。
5. 现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。
```

- 触发方式
```text
（1）手动触发（使用bgrewriteaof命令）
    
（2）自动触发（配置文件）
    appendonly：是否打开AOF持久化功能
    appendfilename：AOF文件名称
    appendfsync：同步频率
    auto-aof-rewrite-min-size：如果文件大小小于此值不会触发AOF，默认64MB
    auto-aof-rewrite-percentage：Redis记录最近的一次AOF操作的文件大小，如果当前AOF文件大小增长超过这个百分比则触发一次重写，默认100
```

- 持久化执行策略
```text
AOF 持久化方案提供 3 种不同时间策略将数据同步到磁盘中，同步策略通过 appendfsync 指令完成：
1. everysec（默认）：表示每秒执行一次 fsync 同步策略，效率上同 RDB 持久化差不多。由于每秒同步一次，所以服务器故障时会丢失 1 秒内的数据。
2. always: 每个写命令都会调用 fsync 进行数据同步，最安全但影响性能。
3. no: 表示 Redis 从不执行 fsync，数据将完全由内核控制写入磁盘。对于 Linux 系统来说，每 30 秒写入一次。
```
- 优缺点

**优点:**
```text
1. 安全性更好：提供比 RDB 持久化方案更安全的数据，由于默认采用每秒进行持久化处理，所有即使服务器重启或宕机，最多也就丢失 1 秒内的数据。

2. 文件内容易懂：AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易
   被人读懂， 对文件进行分析（parse）也很轻松。
```
    
缺点:
```text
1. 文件大：相比于 RDB 持久化，AOF 文件会比 RDB 备份文件大得多。
2. 速度慢：AOF 持久化的速度可能比 RDB 持久化速度慢。
```


## 4. Redis 事务

Redis在事务没提交之前不会执行事务中的命令，会等到事务提交的那一刻再执行事务中的所有命令。

```bash
redis> MULTI  #标记事务开始
OK
redis> INCR user_id  #多条命令按顺序入队
QUEUED
redis> INCR user_id
QUEUED
redis> INCR user_id
QUEUED
redis> PING
QUEUED
redis> EXEC  #执行
1) (integer) 1
2) (integer) 2
3) (integer) 3
4) PONG
```

#### 4.1 事务对异常的处理机制

###### 4.1.1 命令错误

开启事务之后，往事务中添加的命令如果有命令错误（语法错误），那么整个事务中的命令都不会执行。

###### 4.1.1 运行时错误

如果语法没有错误，而执行过程中发生了运行时错误，Redis不仅不会回滚事务，还会跳过这个运行时错误，继续向下执行命令。

#### 4.2 watch

在 multi 命令之前我们可以使用 watch 命令来”观察”一个或多个key，在事务提交之前Redis会确保被”观察”的key有没有被修改过，没有被修改过才会执行
事务中的命令，如果存在key被修改过，那么整个事务中的命令都不会执行，有点类似于乐观锁的机制。



## 5 分布式锁

分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，
往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。实现分布式锁有很多实现方式和工具，如Zookeeper、Redis等。

#### 5.1 使用Redis实现分布式锁原理

Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系，基于此，Redis中可以使用SETNX(不存在就设置)命令实现分布式锁。

![image](https://github.com/jeremyke/PHPBlog/raw/master/Pictures/a79bfc7bc742995234d375bfff6e1c17_SouthEast.png)
 
左图首先使用setnx对键加锁成功返回1，右图再次使用setnx命令对键加锁失败返回0，说明有客户端持有锁。使用del释放锁以后，右图就可以使用setnx命令对键加锁。

#### 5.2 解决死锁

给锁设置一个过期时间，可以通过两种方法实现：通过命令 “setnx 键名 过期时间 “；或者通过设置锁的expire时间，让Redis去删除锁。

###### 5.2.1 方式一:

通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。

```bash
tryLock() {
    SETNX Key 1 Seconds
}
release() {
    DELETE Key
}
#缺陷：C1 执行时间过长未主动释放锁，C2 在 C1 的锁超时后获取到锁，C1 和 C2 都同时在执行，可能造成数据不一致等未知情况。
#如果 C1 先执行完毕，则会释放 C2 的锁，此时可能导致另外一个 C3 获取到锁
```
#### 5.2.2 方式二

使用 setnx key “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现。

```bash
tryLock() {
    SETNX Key UnixTimestamp Seconds
}
release() {
    EVAL(
        #LuaScript
        if redis.call("get",KEYS[1] == ARGV[1])then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
    )
}
#缺陷：极高并发场景下(如抢红包场景)，可能存在 UnixTimestamp 重复问题。分布式环境下物理时钟一致性，也无法保证，也可能存在 UnixTimestamp 重复问题
```
###### 5.2.3 方式三
```bash
tryLock() {
    SET Key UniqId Seconds
}
release() {
    EVAL (
        //LuaScript
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
    )
}
#执行 SET key value NX 的效果等同于执行 SETNX key value。目前最优的分布式锁方案，但是如果在集群下依然存在问题。由于 Redis 集群数据同步为异步，
# 假设在 Master 节点获取到锁后未完成数据同步情况下 Master 节点 crash，在新的 Master 节点依然可以获取锁，所以多个 Client 同时获取到了锁
```
## 6. 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题

#### 6.1 缓存雪崩

我设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，
严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。

**解决办法：**
```text
大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落
到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。
```

#### 6.2 缓存穿透

缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返
回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。

**解决办法：**

```text
方法一：采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

方法二：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通
       过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。
```

#### 6.3 缓存预热

缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

**解决办法：**

```text
1、直接写个缓存刷新页面，上线时手工操作下；
2、数据量不大，可以在项目启动的时候自动进行加载；
3、定时刷新缓存；
```

#### 6.4 缓存更新

除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰。常见的策略有两种：

```text
（1）定时去清理过期的缓存；

（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。
```
两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂!


#### 6.5 缓存降级

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以
根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。

以参考日志级别设置预案：
```text
（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。
```
服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常
见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。

## 7. Redis 过期策略及内存淘汰机制

#### 7.1 过期策略
>Redis 的过期策略就是指当 Redis 中缓存的 Key 过期了，Redis 如何处理

```text
定时过期：每个设置过期时间的 Key 创建定时器，到过期时间立即清除。内存友好，CPU 不友好

惰性过期：访问 Key 时判断是否过期，过期则清除。CPU 友好，内存不友好

定期过期：隔一定时间，expires 字典中扫描一定数量的 Key，清除其中已过期的 Key。内存和 CPU 资源达到最优的平衡效果
```
#### 7.2 内存淘汰机制

```text
[root]# redis-cli config get maxmemory-policy
1) "maxmemory-policy"
2) "noeviction"
```
```text
noeviction：新写入操作会报错
allkeys-lru：移除最近最少使用的 key
allkeys-random：随机移除某些 key
volatile-lru：在设置了过期时间的键中，移除最近最少使用的 key
volatile-random：在设置了过期时间的键中，随机移除某些 key
volatile-ttl：在设置了过期时间的键中，有更早过期时间的 key 优先移除
```

## 8. Redis 的 7 个应用场景
```text
1. 缓存 —— 热数据：
    热点数据（经常会被查询，但是不经常被修改或者删除的数据）
2. 计数器： 统计点击数等应用
3. 队列： 相当于消息系统； 队列不仅可以把并发请求变成串行，并且还可以做队列或者栈使用
4. 位操作（大数据处理）：
    用于数据量上亿的场景下，例如几亿用户系统的签到，去重登录次数统计，某用户是否在线状态等等。
    想想一下腾讯 10 亿用户，要几个毫秒内查询到某个用户是否在线，你能怎么做？千万别说给每个用户建立一个 key，然后挨个记（你可以算一下需要的内存会很恐怖，而且这种类似的需求很多，腾讯光这个得多花多少钱。。）好吧。这里要用到位操作 —— 使用 setbit、getbit、bitcount 命令。
    原理是：redis 内构建一个足够长的数组，每个数组元素只能是 0 和 1 两个值，然后这个数组的下标 index 用来表示我们上面例子里面的用户 id（必须是数字哈），那么很显然，这个几亿长的大数组就能通过下标和元素值（0 和 1）来构建一个记忆系统，上面我说的几个场景也就能够实现。用到的命令是：setbit、getbit、bitcount
5. 分布式锁与单线程机制：
    验证前端的重复请求（可以自由扩展类似情况），可以通过 redis 进行过滤：每次请求将 request Ip、参数、接口等 hash 作为 key 存储 redis（幂等性请求），设置多长时间有效期，然后下次请求过来的时候先在 redis 中检索有没有这个 key，进而验证是不是一定时间内过来的重复提交
    秒杀系统，基于 redis 是单线程特征，防止出现数据库 “爆破”
    全局增量 ID 生成，类似 “秒杀”
6. 最新列表：
    例如新闻列表页面最新的新闻列表，如果总数量很大的情况下，尽量不要使用 select a from A limit 10 这种 low 货，尝试 redis 的 LPUSH 命令构建 List，
    一个个顺序都塞进去就可以啦。不过万一内存清掉了咋办？也简单，查询不到存储 key 的话，用 mysql 查询并且初始化一个 List 到 redis 中就好了。
7. 排行榜
    谁得分高谁排名往上。命令：ZADD（有续集，sorted set）
```

