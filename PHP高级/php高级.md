## 1. yield

#### 1.1 yield 是什么，使用场景?

它最简单的调用形式看起来像一个return申明，不同之处在于普通return会返回值并终止函数的执行，而yield会返回一个值给循环调用此生成器的代码并且只是暂停执行生成器函数。

我的简单理解：yield起一个暂停程序的作用，比如在一个循环中，程序执行遇到yield语句就会返回yield声明的数据，而不是循环完整体返回，加了yield后就会挨个返回。

Caution：如果在一个表达式上下文(例如在一个赋值表达式的右侧)中使用yield，你必须使用圆括号把yield申明包围起来。 例如这样是有效的：$data = (yield $value);
```php
<?php

/**
 * 生成一个长度为$num的数组
 *
 * @param $num
 * @return array
 */
function createRange($num)
{
    for ($i = 0; $i < $num; $i++) {
        sleep(1);
        yield time();
    }
}

$arr = createRange(10);

foreach ($arr as $val) {
    echo $val;
}
```
分析:
```text
# 执行时, 程序每间隔1s输出一个$val
# $arr的生成依赖于foreach, foreach每循环一次, $arr就生成一个值
# 无论$num是100万或更大数据时, $arr都会只在内存中记录一条数据, 节约大量的内存
```


## 2. PHP 进程模型，进程通讯方式，进程线程区别

#### 进程，线程，协程的定义
```text
(1)进程（Process）
    进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。
进程一般由程序，数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和
工作区；程序控制块包含进程的描述信息和控制信息。
    特点：
        动态性：进程是程序的一次执行过程，是临时的，有生命周期的，是动态产生，动态消亡的；
        
        并发性：任何进程都可以同其他进行一起并发执行；
        
        独立性：进程是系统进行资源分配和调度的一个独立单位；
        
        结构性：进程由程序，数据和进程控制块三部分组成。                
                    
(2)线程
    线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是CPU调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间
共享所在进程的内存空间。一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个
或多个线程组成。
    特点：
        不稳定性：线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
        相互制约性：一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。
        
（3）进程与线程的区别
    1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
    
    2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线
    
    3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信
    
    号等)，某进程内的线程在其他进程不可见；
    
    4. 调度和切换：线程上下文切换比进程上下文切换要快得多。

（4）协程
    协程是一种轻量级的线程，由用户代码来调度和管理，而不是由操作系统内核来进行调度，也就是在用户态进行。以swoole为例，Swoole 的每个 Worker
进程 会存在一个协程调度器来调度协程，协程切换的时机就是遇到 I/O 操作或代码显性切换时，进程内以单线程的形式运行协程，也就意味着一个进程内同一
时间只会有一个协程在运行且切换时机明确，也就无需处理像多线程编程下的各种同步锁的问题。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器
上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上
下文的切换非常快。
（5）协程与普通线程的区别

    1，在同一时间可以有多个线程处于运行状态，但对于 Swoole 协程来说只能有一个，其它的协程都会处于暂停的状态。
    
    2，普通线程是抢占式的，哪个线程能得到资源由操作系统决定，而协程是协作式的，执行权由用户态自行分配。
```
#### 2.1 PHP 进程模型?

- (1)、PHP-FPM是多进程模式，master进程管理worker进程，进程的数量，都可以通过php-fpm.conf做具体配置，而PHP-FPM的进程，亦可以分为动态模式及静态模式和按需模式。
```text
    ①：静态（static）：直接开启指定数量的php-fpm进程，不再增加或者减少；启动固定数量的进程，占用内存高。但在用户请求波动大的时候，对Linux操作系统进程的
处理上耗费的系统资源低。
    ②：动态（dynamic）：开始的时候开启一定数量的php-fpm进程，当请求量变大的时候，动态的增加php-fpm进程数到上限，当空闲的时候自动释放空闲的进程数到一个下
限。动态模式，会根据max、min、idle children 配置，动态的调整进程数量。在用户请求较为波动，或者瞬间请求增高的时候，进行大量进程的创建、销毁等操作，而造成
Linux负载波动升高，简单来说，请求量少，PHP-FPM进程数少，请求量大，进程数多。优势就是，当请求量小的时候，进程数少，内存占用也小。
    ③：按需模式（ondemand）：这种模式下，在PHP-FPM启动的时候，master进程不会给这个pool启动任何一个worker进程，是按需启动，当有连接过来才会启动。这种模式很
少使用，因为这种模式，基本上是无法适应有一定量级的线上业务的。由于php-fpm是短连接的，所以每次请求都会先建立连接，在大流量的系统上master进程会变得繁忙，占用系统，
cpu资源，不适合大流量环境的部署。
```
按需模式如图说明：

![image](https://github.com/jeremyke/PHPBlog/raw/master/Pictures/1012804-968e65ef3010cebd.webp)

每个php-fpm进程占用30M内存，所有一般2G内存设置只内存为50个比较合适。

- (2)、PHP-FPM并不是是主进程接收请求转给子进程，而是子进程子进程抢占式的接受用户的请求。

```text
可以通过 trace -p [pid]命令去跟踪系统调用即可。分别跟踪php-fpm的主进程id以及php-fpm子进程id，然后访问nginx，由nginx通过fast-cgi协议转到php-fpm进程上，
看在哪个进程上发送了系统调用。
```
- (3)、PHP-FPM模式下的Yac为何无法和Cli模式无法共享内存。
```text
PHP-FPM模式下，在PHP-FPM进程启动的时候，便初始化一块共享内存，供各个进程来共享使用。开启共享内存需要的系统ID，shared_segment_name，此值，包含了进程的ID。
也就是php-fpm的主进程id。这就是，PHP-FPM模式所有进程间能够通信的奥秘所在（它们有相同的共享内存标识ID）。
在CLI模式下，这样是不可能拿到PHP-FPM模式下设置的共享内存数据的因为，因为CLI模式下，执行php脚本，进程ID，和PHP-FPM模式下的进程ID，根本就不相同。

```
#### 2.2 进程通讯方式
```text
pcntl扩展：主要的进程扩展，完成进程的创建，子进程的创建，也是当前使用比较广的多进程。

posix扩展：完成posix兼容机通用api,如获取进程id,杀死进程等。主要依赖 IEEE 1003.1 (POSIX.1) ，兼容posix

sysvmsg扩展：实现system v方式的进程间通信之消息队列。

sysvsem扩展：实现system v方式的信号量。

sysvshm扩展：实现system v方式的共享内存。

sockets扩展：实现socket通信，跨机器，跨平台。
```
#### 线程之间的通信
```text
锁机制：包括互斥锁、条件变量、读写锁

互斥锁：提供了以排他方式防止数据结构被并发修改的方法。

读写锁：允许多个线程同时共享数据，而对写操作是互斥的。

条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

信号量机制（Semaphore）：包括无名进程信号量和命名线程信号量

信号机制（Signal）：类似进程间的信号处理
```
#### 2.3 进程线程区别
```text
    1) 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间。
    2) 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源。
    3) 线程是处理器调度的基本单位,但进程不是。
    4) 二者均可并发执行。
    5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制
    6) 速度:线程产生的速度快，通讯快，切换快，因为他们处于同一地址空间。 
    7) 线程的资源利用率好。 
    8) 线程使用公共变量或者内存的时候需要同步机制，但进程不用。
   
```
#### 线程、协程比较
```text
1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程。

2) 线程进程都是同步机制，而协程则是异步。

3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。
```
#### 2.4 PHP多进程
- 关于pcntl函数
```text
# pcntl_fork()函数
系统从当前进程生成一个新的进程, 原来的进程叫做父进程, 新生成的进程叫做子进程，子进程获得父进程数据空间、堆和栈的复制。
pcntl_fork()执行一次, 返回两次, 一次返回到新进程(0), 一次返回到父进程(子进程的pid).
子进程从pcntl_fork()返回后的位置开始执行, 但是拥有父进程前面定义的变量名和变量值.
pcntl_fork()执行失败返回-1.
一般来说, 在pcntl_fork()之后是父进程先执行还是子进程先执行是不确定的, 这取决于内核所使用的调度算法.

# posix_getpid()
返回当前进程ID

# posix_getppid()
返回父进程ID

# pcntl_wait()
阻塞当前的进程直到子进程退出, 父进程回收子进程的资源, 防止产生僵尸进程
```
- 创建子进程
```php
<?php

echo '父进程ID: ' . posix_getpid() . PHP_EOL;

$pid = pcntl_fork();

switch ($pid) {
    case -1:
        die('fork failed');
        break;
    case 0:
        echo '子进程ID: ' . posix_getpid() . PHP_EOL;
        sleep(2);
        echo '子进程已经退出';
        break;
    default:
        pcntl_wait($status);
        echo '父进程已经退出' . PHP_EOL;
        break;
}
```
运行结果：
```text
[root@e2963c647c8b www]# php threads.php
父进程ID: 573
子进程ID: 574
子进程已经退出父进程已经退出
```
- 理解pcntl_wait()
>pcntl_wait()在子进程退出之前会阻塞, 直到一个子进程退出后再创建另外一个子进程



## 3. PHP 7 与 PHP 5 有什么区别？

#### 3.1 php标量类型和返回类型声明
```text
#主要分为两种模式，强制性模式和严格模式
declare(strict_types=1)
#1表示严格类型校验模式，作用于函数调用和返回语句；0表示弱类型校验模式。
```
#### 3.2 NULL合并运算符
```text
$site = isset($_GET['site']) ? $_GET['site'] : 'wo';
#简写成
$site = $_GET['site'] ??'wo';
```
#### 3.3 组合预算符
```text
// 整型比较
print( 1 <=> 1);print(PHP_EOL);
print( 1 <=> 2);print(PHP_EOL);
print( 2 <=> 1);print(PHP_EOL);
print(PHP_EOL); // PHP_EOL 为换行符
//结果：
0
-1
1
```
#### 3.4 常量数组
```text
// 使用 define 函数来定义数组
define('sites', [
   'Google',
   'Jser',
   'Taobao'
]);

print(sites[1]);
```
#### 3.5 匿名类
```php
<?php

interface Logger { 
   public function log(string $msg); 
} 

class Application { 
   private $logger; 

   public function getLogger(): Logger { 
      return $this->logger; 
   } 

   public function setLogger(Logger $logger) { 
      $this->logger = $logger; 
   }   
} 

$app = new Application; 
// 使用 new class 创建匿名类 
$app->setLogger(new class implements Logger { 
   public function log(string $msg) { 
      print($msg); 
   } 
}); 

$app->getLogger()->log("我的第一条日志"); 
```

#### 3.6 Closure::call()方法增加，意思向类绑定个匿名函数
```php
<?php 
class A { 
    private $x = 1; 
} 

// PHP 7 之前版本定义闭包函数代码 
$getXCB = function() { 
    return $this->x; 
}; 

// 闭包函数绑定到类 A 上 
$getX = $getXCB->bindTo(new A, 'A');  

echo $getX(); 
print(PHP_EOL); 

// PHP 7+ 代码 
$getX = function() { 
    return $this->x; 
}; 
echo $getX->call(new A); 
?>
```
#### 3.7 CSPRNG（伪随机数产生器）
```text
PHP 7 通过引入几个 CSPRNG 函数提供一种简单的机制来生成密码学上强壮的随机数。

random_bytes() - 加密生存被保护的伪随机字符串。

random_int() - 加密生存被保护的伪随机整数。
```
#### 3.8 use语句改变
```text
#可以导入同一个namespace下的类简写
use some\namespace\{ClassA, ClassB, ClassC as C};
```
#### 3.8 Session 选项
```text
1.session_start()可以定义数组
<?php
session_start(&#91;
   'cache_limiter' => 'private',
   'read_and_close' => true,
]);
?>
2.引入了一个新的php.ini设置（session.lazy_write）,默认情况下设置为 true，意味着session数据只在发生变化时才写入。
```
####  PHP7 比 PHP5 性能提升了？
```text
1、变量存储字节减小，减少内存占用，提升变量操作速度

2、改善数组结构，数组元素和hash映射表被分配在同一块内存里，降低了内存占用、提升了 cpu 缓存命中率

3、改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率
```


