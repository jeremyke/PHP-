 ## 1.Cookie 和 Session
 
 #### 1.1 工作原理？
 
 session的常见实现形式是会话cookie（session cookie），即未设置过期时间的cookie，这个cookie的默认生命周期为浏览器会话期间，仅仅要关闭浏览器窗体，cookie就消失了。实现机制是当用户发起一个请求的时候，server会检查该请求中是否包括sessionid，假设未包括，则系统会创造一个名为JSESSIONID的输出 cookie返回给浏览器(仅仅放入内存，并不存在硬盘中)，并将其以HashTable的形式写到server的内存里面；当已经包括sessionid是，服务端会检查找到与该session相匹配的信息，假设存在则直接使用该sessionid，若不存在则又一次生成新的 session。这里须要注意的是session始终是有服务端创建的，并不是浏览器自己生成的。　可是浏览器的cookie被禁止后session就须要用get方法的URL重写的机制或使用POST方法提交隐藏表单的形式来实现。
 
 ```text
 Cookie:服务器端生成，储存在用户浏览器端，用于记录web用户的基本信息。
 Session：服务器端生成，储存在服务器端，而本地浏览器会存储一个与服务器中session文件对应的Cookie值。Session 对象存储特定用户会话所需的属性及配置信息。
 
 COOKIE和SESSION的区别：
    （1）存储位置：Cookie存储在客户端浏览器中，相对不安全；Session内容所在文件存储在服务器中，一般在根目录下的tmp文件夹中，相对更安全。
    （2）数量和大小限制：Cookie存储的数据在不同的浏览器会有不同的限制，一般在同一个域名下，Cookie变量数量控制在20个以内，每个cookie值的大
 小控制在4kb以内。session值没有大小和数量限制，但如果数量过多，会增大服务器的压力。
    （3）内容区别：cookie保存的内容是字符串，而服务器中的session保存的数据是对象。
    （4）路径区别：session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到；而cookie中如果设置了路径参数，
 那么同一个网站中不同路径下的cookie互相是访问不到的。
 
 用户禁用cookie如何使用session?
    方法一：php.ini文件设置 session.use_trans_sid = 1，这样他会在每个url后面自动加上PHPSESSID的值，然后正常使用session就可以了。
    方法二：保存session_id的值于数据库或redis中，然后在下一次要调用session前，运行session_id（$session_id），
 还有这条语句要在session_start()前。
 
 ```
 #### 1.2 session共享?
 
 - 为什么要做session共享？
 ```text
 首先我们应该明确，为什么要实现共享，假设你的站点是存放在一个机器上，那么是不存在这个问题的，由于会话数据就在这台机器，可是假设你使用了负载均衡
 把请求分发到不同的机器呢？这个时候会话id在client是没有问题的，可是假设用户的两次请求到了两台不同的机器，而它的session数据可能存在当中一台机器，
 这个时候就会出现取不到session数据的情况，于是session的共享就成了一个问题。
 ```
 - 如何做到session共享？
 ```text
 1.持久化session到数据库，即使用数据库来储存session。数据库正好是我们普遍使用的公共储存空间，一举两得，推荐使用mysql数据库，轻量并且性能良好。
    优点：就地取材，符合大多数人的思维，使用简单，不需要太多额外编码工作。
    缺点：对mysql性能要求较高，访问mysql需要从连接池中获取连接，又因为大部分请求均需要进行登录鉴权，所以操作数据库非常频繁，当用户量达到一定程度之后，
        极易造成数据库瓶颈，不适用于处理高并发的情况。
 2.使用redis共享session。redis是一个key-value的储存系统。可以简单的将其理解为一个数据库，与传统数据库的区别是，它将数据储存于内存中，并自带有内存到硬盘的序列化策略，
   即按策略将内存中的数据同步到磁盘，避免数据丢失，是目前比较流行的解决方案。
    优点：无需增加数据库的压力，因为数据存储于内存中，所以读取非常快，高性能，并能处理多种类型的数据。 
    缺点：额外增加一些编码，以便操作redis。
 3.使用memcache同步session，memcache可以实现分布式，可将服务器中的内存组合起来，形成一个“内存池”，以此充当公共空间，保存session信息。
    优点：数据储存在内存中，读取非常快，性能好； 
    缺点：memcache把内存分成很多种规格的存储块，有大有小，不能完全利用内存，会产生内存碎片，浪费资源，如果储存块不足，还会产生内存溢出。
 4.使用NFS共享session。NFS是Network File Server共享服务器的简称，最早由Sun公司为解决Unix网络主机间的目录共享而研发。选择一台公共的NFS做共享服务器，
   储存所有session数据，每台服务器所需的session均从此处获取。
    优点：较好的实现了session共享； 
    缺点：成本较高，对于个人来说难以实现。NFS依托于复杂的安全机制和文件系统，因此并发效率不高。
 ```
 - 设置session存活时间
 ```text
 (1) 修改php.ini
    session.gc_maxlifetime = 1440
 (2) 采用增加cookie的时间，变相的增加session的时间
 ```
 
 ## 2. POST和GET区别
 ```text
 （1）传输内容大小：
     POST 根据php.ini文件配置，默认8M
     GET 2K
 （2）提交方式：
     POST 放在请求空白行中提交的
     GET 追加在URL上面的
 （3）安全性：
     POST 更安全
 ```
 
 ## 3. 常见 API 的 APP_ID APP_SECRET 主要作用是什么？
 ```text
 客户端（app/浏览器）将用户导向第三方认证服务器
 
 用户在第三方认证服务器，选择是否给予客户端授权
 
 用户同意授权后，认证服务器将用户导向客户端事先指定的重定向URI，同时附上一个授权码。
 
 客户端将授权码发送至服务器，服务器通过授权码以及APP_SECRET向第三方服务器申请access_token
 
 服务器通过access_token，向第三方服务器申请用户数据，完成登陆流程，
 
 APP_SECRET 存储在客户端，客户端获取授权码之后，直接通过授权码和 APP_SECRET 去第三方换取 access_token。
 
 APP_SECRET 存储在服务端，客户端获取授权码之后，将授权码发送给服务器，服务器通过授权码和 APP_SECRET 去第三方换取 access_token。（推荐）
 ```
 
 ## 4. 数据加密和验签的区别
 #### 4.1 非对称加密
 ```text
 加密过程是把私钥自己保存下来，把公钥开放了发布出去，然后其他人通过公钥加密给你通信，由于只能由私钥解密，所以最后数据只有你能够读取；
 签名就正好相反，是你把数据通过私钥加密了然后把数据发出去，别人能够通过你的公钥解密数据就表示这个数据是你发出来的。
 ```
 #### 4.2 RSA
 ```text
 RSA加密算法是一种非对称加密算法。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。
 今天只有短的RSA钥匙才可能被强力方式解破。到当前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。
 ```
 
 ## 5. OAuth 2.0
 #### 5.1 授权码模式工作原理？
 
 ![image](https://github.com/jeremyke/PHPBlog/raw/master/Pictures/77242a8943acb4f36dc150daf170a13f_70.png)
 
 - 步骤：
 ```text
 (1)第三方去平台去报备，申请我的xxx地址使用你的接口，等平台审核通过之后，会下发一组appid+appkey，第三方持凭此就有资格去请求该平台的接口了
 (2)用户访问第三方，第三方请求访问平台接口。
 (3)用户授权，第三方获取平台的code。
 (4)第三方通过code请求第三方，获取到access_token。
 (5)第三方获通过access_token调用平台接口获取到相应的数据。
 ```
 ## 6. JWT
 ```text
 JSON WEB Token（JWT，读作 [/dʒɒt/]），是一种基于JSON的、用于在网络上声明某种主张的令牌（token）。JWT通常由三部分组成: 头信息（header）, 消息体（payload）和签名（signature）。
 
 一个很好理解的对jwt的介绍：
 
 服务B你好, 服务A告诉我，我可以操作<JWT内容>, 这是我的凭证（即JWT）
 ```
 
 
 