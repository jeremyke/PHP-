 ## 1.Cookie 和 Session

 #### 1.1 工作原理？

 session的常见实现形式是会话cookie（session cookie），即未设置过期时间的cookie，这个cookie的默认生命周期为浏览器会话期间，关闭浏览器窗体，cookie就消失了。实现机制是当用户发起一个请求的时候，服务器会检查该请求中是否包括sessionid，假设未包括，则系统会创造一个名为SESSION_ID的输出 cookie返回给浏览器(仅仅放入内存，并不存在硬盘中)，并将其以HashTable的形式写到服务器的内存里面；当已经包括sessionid时，服务端会检查找到与该session相匹配的信息，假设存在则直接使用该sessionid，若不存在则又一次生成新的session。这里须要注意的是session始终是有服务端创建的，并不是浏览器自己生成的。　可是浏览器的cookie被禁止后session就须要用get方法的URL重写的机制或使用POST方法提交隐藏表单的形式来实现。

 ```text
 Cookie:服务器端生成，储存在用户浏览器端，用于记录web用户的基本信息。
 Session：服务器端生成，储存在服务器端，而本地浏览器会存储一个与服务器中session文件对应的Cookie值。Session 对象存储特定用户会话所需的属性及配置信息。
 
 COOKIE和SESSION的区别：
    （1）存储位置：Cookie存储在客户端浏览器中，相对不安全；Session内容所在文件存储在服务器中，一般在根目录下的tmp文件夹中，相对更安全。
    （2）数量和大小限制：Cookie存储的数据在不同的浏览器会有不同的限制，一般在同一个域名下，Cookie变量数量控制在20个以内，每个cookie值的大
 小控制在4kb以内。session值没有大小和数量限制，但如果数量过多，会增大服务器的压力。
    （3）内容区别：cookie保存的内容是字符串，而服务器中的session保存的数据是对象。
    （4）路径区别：session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到；而cookie中如果设置了路径参数，
 那么同一个网站中不同路径下的cookie互相是访问不到的。
 
 用户禁用cookie如何使用session?
    方法一：php.ini文件设置 session.use_trans_sid = 1，这样他会在每个url后面自动加上PHPSESSID的值，然后正常使用session就可以了。
    方法二：保存session_id的值于数据库或redis中，然后在下一次要调用session前，运行session_id（$session_id），
 还有这条语句要在session_start()前。
 
 ```
 #### 1.2 session共享?

 - 为什么要做session共享？
 ```text
 首先我们应该明确，为什么要实现共享，假设你的站点是存放在一个机器上，那么是不存在这个问题的，由于会话数据就在这台机器，可是假设你使用了负载均衡
 把请求分发到不同的机器呢？这个时候会话id在client是没有问题的，可是假设用户的两次请求到了两台不同的机器，而它的session数据可能存在当中一台机器，
 这个时候就会出现取不到session数据的情况，于是session的共享就成了一个问题。
 ```
 - 如何做到session共享？
 ```text
 1.持久化session到数据库，即用数据库来储存session。数据库正好是我们普遍使用的公共储存空间，一举两得，推荐使用mysql数据库，轻量并且性能良好。
    优点：就地取材，符合大多数人的思维，使用简单，不需要太多额外编码工作。
    缺点：对mysql性能要求较高，访问mysql需要从连接池中获取连接，又因为大部分请求均需要进行登录鉴权，所以操作数据库非常频繁，当用户量达到一定程度之后，
        极易造成数据库瓶颈，不适用于处理高并发的情况。
 2.使用redis共享session。redis是一个key-value的储存系统。可以简单的将其理解为一个数据库，与传统数据库的区别是，它将数据储存于内存中，并自带有内存到硬盘的序列化策略，
   即按策略将内存中的数据同步到磁盘，避免数据丢失，是目前比较流行的解决方案。
    优点：无需增加数据库的压力，因为数据存储于内存中，所以读取非常快，高性能，并能处理多种类型的数据。 
    缺点：额外增加一些编码，以便操作redis。
 3.使用memcache同步session，memcache可以实现分布式，可将服务器中的内存组合起来，形成一个“内存池”，以此充当公共空间，保存session信息。
    优点：数据储存在内存中，读取非常快，性能好； 
    缺点：memcache把内存分成很多种规格的存储块，有大有小，不能完全利用内存，会产生内存碎片，浪费资源，如果储存块不足，还会产生内存溢出。
 4.使用NFS共享session。NFS是Network File Server共享服务器的简称，最早由Sun公司为解决Unix网络主机间的目录共享而研发。选择一台公共的NFS做共享服务器，
   储存所有session数据，每台服务器所需的session均从此处获取。
    优点：较好的实现了session共享； 
    缺点：成本较高，对于个人来说难以实现。NFS依托于复杂的安全机制和文件系统，因此并发效率不高。
 ```
 - 设置session存活时间
 ```text
 (1) 修改php.ini
    session.gc_maxlifetime = 1440
 (2) 采用增加cookie的时间，变相的增加session的时间
 ```

 ## 2. POST和GET区别
 ```text
 （1）传输内容大小：
     POST 根据php.ini文件配置，默认8M
     GET 2K
 （2）提交方式：
     POST 放在请求空白行中提交的
     GET 追加在URL上面的
 （3）安全性：
     POST 更安全
 ```

 ## 3. 常见 API 的 APP_ID APP_SECRET 主要作用是什么？
 ```text
 客户端（app/浏览器）将用户导向第三方认证服务器
 
 用户在第三方认证服务器，选择是否给予客户端授权
 
 用户同意授权后，认证服务器将用户导向客户端事先指定的重定向URI，同时附上一个授权码。
 
 客户端将授权码发送至服务器，服务器通过授权码以及APP_SECRET向第三方服务器申请access_token
 
 服务器通过access_token，向第三方服务器申请用户数据，完成登陆流程，
 
 APP_SECRET 存储在客户端，客户端获取授权码之后，直接通过授权码和 APP_SECRET 去第三方换取 access_token。
 
 APP_SECRET 存储在服务端，客户端获取授权码之后，将授权码发送给服务器，服务器通过授权码和 APP_SECRET 去第三方换取 access_token。（推荐）
 ```

 ## 4. 数据加密和验签的区别
 #### 4.1 非对称加密
 ```text
 加密过程是把私钥自己保存下来，把公钥开放了发布出去，然后其他人通过公钥加密给你通信，由于只能由私钥解密，所以最后数据只有你能够读取；
 签名就正好相反，是你把数据通过私钥加密了然后把数据发出去，别人能够通过你的公钥解密数据就表示这个数据是你发出来的。
 ```
 #### 4.2 RSA
 ```text
 RSA加密算法是一种非对称加密算法。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。
 今天只有短的RSA钥匙才可能被强力方式解破。到当前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。
 ```

 ## 5. OAuth 2.0
 #### 5.1 授权码模式工作原理？

 ![image](https://github.com/jeremyke/PHPBlog/raw/master/Pictures/77242a8943acb4f36dc150daf170a13f_70.png)

 - 步骤：
 ```text
 (1)第三方去平台去报备，申请我的xxx地址使用你的接口，等平台审核通过之后，会下发一组appid+appkey，第三方持凭此就有资格去请求该平台的接口了
 (2)用户访问第三方，第三方请求访问平台接口。
 (3)用户授权，第三方获取平台的code。
 (4)第三方通过code请求第三方，获取到access_token。
 (5)第三方获通过access_token调用平台接口获取到相应的数据。
 ```
 ## 6. JWT
 ```text
 JSON WEB Token（JWT，读作 [/dʒɒt/]），是一种基于JSON的、用于在网络上声明某种主张的令牌（token）。JWT通常由三部分组成: 头信息（header）, 消息体（payload）和签名（signature）。
 
 一个很好理解的对jwt的介绍：
 
 服务B你好, 服务A告诉我，我可以操作<JWT内容>, 这是我的凭证（即JWT）
 ```
 ## 7. HTTPS的原理

 HTTPS协议 = HTTP协议 + SSL/TLS协议，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。

 ![image](https://github.com/jeremyke/PHPBlog/raw/master/Pictures/627325-dc83fef6ac2e6c88.webp.jpg)

 #### 7.1 步骤

1.客户端发起一个https的请求，把自身支持的一系列加密算法发送给服务端

2.服务端，接收到客户端所有的Cipher后与自身支持的对比，如果不支持则连接断开，反之则会从中选出一种加密算法和HASH算法以证书的形式返回给客户端
证书中还包含了 公钥 颁证机构 网址 失效日期等等。


3.客户端收到服务端响应后会做以下几件事

3.1验证证书的合法性
```text
颁发证书的机构是否合法与是否过期，证书中包含的网站地址是否与正在访问的地址一致等

证书验证通过后，在浏览器的地址栏会加上一把小锁(每家浏览器验证通过后的提示不一样 不做讨论)
```
3.2 生成随机密码
```text
如果证书验证通过，或者用户接受了不授信的证书，此时浏览器会生成一串随机数，然后用证书中的公钥加密。 
```

3.3 取握手消息的hash值
```text
用最开始约定好的HASH方式，把握手消息取HASH值，然后用随机数加密 “握手消息+握手消息HASH值(签名)”  并一起发送给服务端

在这里之所以要取握手消息的HASH值，主要是把握手消息做一个签名，用于验证握手消息在传输过程中没有被篡改过。
```

4.客户端把用公钥加密的随机数+用随机数加密的握手消息（握手消息的hash值+握手消息），一起发给服务器。


5.服务端拿到客户端传来的密文，用自己的私钥来解密握手消息取出随机数密码，再用随机数密码解密握手消息与HASH值，再用同样的hash算法求得握手消息的hash值，
并与传过来的HASH值做对比确认是否一致。

6.然后用随机密码加密(握手消息+握手消息的HASH值)给客户端

7.客户端用随机数解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。之后所有的通信数据将由之前浏览器生成的随机密码并利
用对称加密算法进行加密因为这串密钥只有客户端和服务端知道，所以即使中间请求被拦截也是没法解密数据的，以此保证了通信的安全。


#### 7.2 加密算法

- 非对称加密算法：RSA，DSA/DSS在客户端与服务端相互验证的过程中用的是对称加密 
- 对称加密算法：AES，RC4，3DES客户端与服务端相互验证通过后，以随机数作为密钥时，就是对称加密
- HASH算法：MD5，SHA1，SHA256在确认握手消息没有被篡改时 

 
