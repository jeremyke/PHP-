## 1 概念

#### 1.1 
PHP 进程模型，进程通讯方式，进程线程区别

yield 是什么，说个使用场景 yield、yield 核心原理是什么















#### 1、PHP-FPM是多进程模式，master进程管理worker进程，进程的数量，都可以通过php-fpm.conf做具体配置，而PHP-FPM的进程，亦可以分为动态模式及静态模式和按需模式。
```text
    ①：静态（static）：直接开启指定数量的php-fpm进程，不再增加或者减少；启动固定数量的进程，占用内存高。但在用户请求波动大的时候，对Linux操作系统进程的
处理上耗费的系统资源低。
    ②：动态（dynamic）：开始的时候开启一定数量的php-fpm进程，当请求量变大的时候，动态的增加php-fpm进程数到上限，当空闲的时候自动释放空闲的进程数到一个下
限。动态模式，会根据max、min、idle children 配置，动态的调整进程数量。在用户请求较为波动，或者瞬间请求增高的时候，进行大量进程的创建、销毁等操作，而造成
Linux负载波动升高，简单来说，请求量少，PHP-FPM进程数少，请求量大，进程数多。优势就是，当请求量小的时候，进程数少，内存占用也小。
    ③：按需模式（ondemand）：这种模式下，在PHP-FPM启动的时候，master进程不会给这个pool启动任何一个worker进程，是按需启动，当有连接过来才会启动。这种模式很
少使用，因为这种模式，基本上是无法适应有一定量级的线上业务的。由于php-fpm是短连接的，所以每次请求都会先建立连接，在大流量的系统上master进程会变得繁忙，占用系统，
cpu资源，不适合大流量环境的部署。
```
按需模式如图说明：

![image](https://github.com/jeremyke/PHPBlog/raw/master/Pictures/1012804-968e65ef3010cebd.webp)

每个php-fpm进程占用30M内存，所有一般2G内存设置只内存为50个比较合适。

#### 2、PHP-FPM并不是是主进程接收请求转给子进程，而是子进程子进程抢占式的接受用户的请求。

```text
可以通过 trace -p [pid]命令去跟踪系统调用即可。分别跟踪php-fpm的主进程id以及php-fpm子进程id，然后访问nginx，由nginx通过fast-cgi协议转到php-fpm进程上，
看在哪个进程上发送了系统调用。
```
#### 3、PHP-FPM模式下的Yac为何无法和Cli模式无法共享内存。
```text
PHP-FPM模式下，在PHP-FPM进程启动的时候，便初始化一块共享内存，供各个进程来共享使用。开启共享内存需要的系统ID，shared_segment_name，此值，包含了进程的ID。
也就是php-fpm的主进程id。这就是，PHP-FPM模式所有进程间能够通信的奥秘所在（它们有相同的共享内存标识ID）。
在CLI模式下，这样是不可能拿到PHP-FPM模式下设置的共享内存数据的因为，因为CLI模式下，执行php脚本，进程ID，和PHP-FPM模式下的进程ID，根本就不相同。

```


